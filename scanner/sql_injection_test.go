package scanner

import (
	"net/http"
	"net/http/httptest"
	"testing"
)

// TestSQLInjectionScannerSuccess tests the case where an SQL injection vulnerability is successfully detected.
func TestSQLInjectionScannerSuccess(t *testing.T) {
	// Mock server that simulates a vulnerable endpoint.
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Simulate a vulnerable response with "syntax error" in the body.
		if r.URL.Query().Get("input") == "' OR '1'='1" {
			w.Write([]byte("syntax error"))
		} else {
			w.Write([]byte("safe"))
		}
	}))
	defer ts.Close()

	// Initialize the SQLInjectionScanner.
	sqlScanner := SQLInjectionScanner{} // Make sure this struct is defined in your scanner.go file
	headers := map[string]string{}

	// Perform the scan against the mock server.
	vulnDetails, found := sqlScanner.Scan(ts.URL, headers)

	// Check if the vulnerability was detected.
	if !found {
		t.Errorf("Expected SQL Injection vulnerability to be detected, but it wasn't.")
	}

	// Validate the vulnerability details.
	if vulnDetails.Type != "SQL Injection" {
		t.Errorf("Expected vulnerability type to be 'SQL Injection', got: %s", vulnDetails.Type)
	}
	if vulnDetails.Endpoint != ts.URL+"?input=' OR '1'='1" {
		t.Errorf("Expected endpoint to be '%s', got: %s", ts.URL+"?input=' OR '1'='1", vulnDetails.Endpoint)
	}
	if vulnDetails.Payload != "' OR '1'='1" {
		t.Errorf("Expected payload to be \"' OR '1'='1\", got: %s", vulnDetails.Payload)
	}
}

// TestSQLInjectionScannerNoVuln tests the case where no vulnerability is detected.
func TestSQLInjectionScannerNoVuln(t *testing.T) {
	// Mock server that simulates a safe endpoint.
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("safe"))
	}))
	defer ts.Close()

	// Initialize the SQLInjectionScanner.
	sqlScanner := SQLInjectionScanner{} // Make sure this struct is defined in your scanner.go file
	headers := map[string]string{}

	// Perform the scan against the mock server.
	vulnDetails, found := sqlScanner.Scan(ts.URL, headers)

	// Check if no vulnerability was found.
	if found {
		t.Errorf("Expected no SQL Injection vulnerability, but one was reported.")
	}

	// Check that the vulnerability details are empty.
	if vulnDetails != (VulnerabilityDetails{}) {
		t.Errorf("Expected empty vulnerability details, but got: %+v", vulnDetails)
	}
}
