package scanner

import (
	"fmt"
	"net/http"
	"strings"
	"time"
	"io"
)

// SQLInjectionScanner checks for SQL injection vulnerabilities.
type SQLInjectionScanner struct{}

// Scan performs SQL injection scanning on the target and returns vulnerability details
func (s SQLInjectionScanner) Scan(target string, headers map[string]string) (VulnerabilityDetails, bool) {
	payloads := []string{"' OR '1'='1", "'UNION SELECT NULL --", "' AND SLEEP(5) --"}

	for _, payload := range payloads {
		// Craft the malicious URL
		maliciousURL := target + "?input=" + payload
		req, _ := http.NewRequest("GET", maliciousURL, nil)

		// Add headers
		for key, value := range headers {
			req.Header.Add(key, value)
		}

		// Send the request
		start := time.Now()
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			fmt.Println("Error:", err)
			return VulnerabilityDetails{}, false
		}
		defer resp.Body.Close()

		// Check for SQL error patterns or slow response (for time-based injection)
		body := new(strings.Builder)
		_, err = io.Copy(body, resp.Body)
		if err != nil {
			fmt.Println("Error reading response body:", err)
			return VulnerabilityDetails{}, false
		}

		// Detect common SQL injection patterns or abnormal delays (for time-based injections)
		if strings.Contains(body.String(), "syntax error") || time.Since(start) > 5*time.Second {
			fmt.Println("SQL Injection vulnerability found at:", maliciousURL)

			// Return the vulnerability details
			return VulnerabilityDetails{
				Type:       "SQL Injection",
				Endpoint:   maliciousURL,
				Payload:    payload,
				DetectedAt: time.Now(),
				Suggestion: "Use prepared statements and parameterized queries to prevent SQL injection. Validate and sanitize user inputs.",
			}, true
		}
	}

	// No vulnerability detected
	return VulnerabilityDetails{}, false
}
