package scanner

import (
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

func TestDirectoryTraversalScanner(t *testing.T) {
	scanner := DirectoryTraversalScanner{}
	headers := make(map[string]string)

	tests := []struct {
		name           string
		payload        string
		mockResponse   string
		expectedVuln   bool
		expectedString string
	}{
		{
			name:           "Safe file test",
			payload:        "safe-file.txt",
			mockResponse:   "This is a safe file",
			expectedVuln:   false,
			expectedString: "safe-file.txt",
		},
		{
			name:           "Linux directory traversal test",
			payload:        "../../../../etc/passwd",
			mockResponse:   "root:x:0:0:root:/root:/bin/bash",
			expectedVuln:   true,
			expectedString: "root:x:0:0",
		},
		{
			name:           "Windows directory traversal test",
			payload:        "..\\..\\..\\..\\windows\\system32\\config",
			mockResponse:   "[boot loader]",
			expectedVuln:   true,
			expectedString: "[boot loader]",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Mock the HTTP server
			mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if strings.Contains(r.URL.Query().Get("path"), tt.payload) {
					w.Write([]byte(tt.mockResponse))
				} else {
					w.WriteHeader(http.StatusNotFound)
				}
			}))
			defer mockServer.Close()

			vulnDetails, vulnFound := scanner.Scan(mockServer.URL, headers, tt.payload)

			if vulnFound != tt.expectedVuln {
				t.Errorf("Expected vulnerability: %v, got: %v", tt.expectedVuln, vulnFound)
			}

			if vulnFound {
				if !strings.Contains(vulnDetails.Endpoint, tt.payload) {
					t.Errorf("Expected endpoint containing payload: %s, got: %s", tt.payload, vulnDetails.Endpoint)
				}

				if !strings.Contains(vulnDetails.Payload, tt.payload) {
					t.Errorf("Expected payload: %s, got: %s", tt.payload, vulnDetails.Payload)
				}
			}
		})
	}
}
