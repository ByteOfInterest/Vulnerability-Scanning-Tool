package scanner

import (
	"fmt"
	"net/http"
	"time"
	"io/ioutil"
)

// SQLInjectionScanner implements the VulnerabilityScanner interface for detecting SQL Injection vulnerabilities.
type SQLInjectionScanner struct{}

// Scan performs the SQL Injection scan on the provided target and returns VulnerabilityDetails if detected.
func (s *SQLInjectionScanner) Scan(target string, headers map[string]string) (VulnerabilityDetails, bool) {
	// Control input
	controlInput := "safe_input"
	controlURL := target + "?input=" + controlInput

	// SQL Injection payloads to test
	sqlPayloads := []string{
		"' OR '1'='1",
		"' OR '1'='0'--",
		"'; DROP TABLE users--",
	}

	// Send control request to get the baseline response
	controlResponse, err := sendRequest(controlURL, headers)
	if err != nil {
		fmt.Println("Error:", err)
		return VulnerabilityDetails{}, false
	}

	// Iterate over SQL payloads to check for anomalies
	for _, payload := range sqlPayloads {
		injectedURL := target + "?input=" + payload
		injectedResponse, err := sendRequest(injectedURL, headers)
		if err != nil {
			fmt.Println("Error:", err)
			continue
		}

		// If response differs from control, a vulnerability is detected
		if injectedResponse != controlResponse {
			fmt.Printf("SQL Injection vulnerability found at: %s with payload: %s\n", injectedURL, payload)
			
			vulnerability := VulnerabilityDetails{
				Type:       "SQL Injection",
				Endpoint:   injectedURL,
				Payload:    payload,
				DetectedAt: time.Now(),
				Suggestion: "Sanitize and parameterize SQL queries to prevent injection attacks.",
			}

			// Add vulnerability to the global slice
			AddVulnerability(vulnerability)

			return vulnerability, true
		}
	}

	// No vulnerability detected
	return VulnerabilityDetails{}, false
}

// Helper function to send HTTP GET requests and return the response body as a string
func sendRequest(url string, headers map[string]string) (string, error) {
	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return "", err
	}

	// Add any provided headers
	for key, value := range headers {
		req.Header.Add(key, value)
	}

	// Perform the request
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(body), nil
}
