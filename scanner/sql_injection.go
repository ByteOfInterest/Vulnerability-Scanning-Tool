package scanner

import (
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// SQLInjectionScanner checks for SQL injection vulnerabilities.
type SQLInjectionScanner struct{}

// Scan performs SQLi scanning on the target
func (s SQLInjectionScanner) Scan(target string, headers map[string]string) bool {
	// SQLi payloads to test for vulnerabilities
	payloads := []string{"' OR '1'='1", "' UNION SELECT NULL --", "' AND SLEEP(5) --"}

	for _, payload := range payloads {
		// Craft the malicious URL
		maliciousURL := target + "?input=" + payload

		// Create the HTTP request
		req, _ := http.NewRequest("GET", maliciousURL, nil)

		// Add headers from the configuration
		for key, value := range headers {
			req.Header.Add(key, value)
		}

		// Track the start time for timing attacks
		start := time.Now()

		// Send the request
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			fmt.Println("Error making request:", err)
			return false
		}
		defer resp.Body.Close()

		// Read the response body
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			fmt.Println("Error reading response body:", err)
			return false
		}

		// Check for SQL error patterns in the response or slow responses (time-based SQLi)
		if strings.Contains(string(body), "syntax error") || time.Since(start) > 5*time.Second {
			fmt.Println("SQL Injection vulnerability found!")
			return true
		}
	}

	// No SQLi vulnerabilities found
	return false
}
