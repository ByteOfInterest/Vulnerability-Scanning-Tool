package main

import (
	"Vulnerability-Scanning-Tool/config"
	"Vulnerability-Scanning-Tool/scanner"
	"fmt"
	"os"
	"time"
)

type ScanResult struct {
	Target          string
	Vulnerabilities []scanner.VulnerabilityDetails
}

func main() {
	// Load configuration from config.json
	config, err := config.LoadConfig("config.json")
	if err != nil {
		fmt.Println("Error loading config:", err)
		return
	}

	// All scanners used
	scanners := []scanner.VulnerabilityScanner{
		scanner.SQLInjectionScanner{},
		scanner.XSSScanner{},
		scanner.CSRFScanner{},
		// Add more scanners here
	}

	// Loop through each target and check for vulnerabilities
	for _, target := range config.Targets {
		fmt.Println("Scanning target:", target)

		for _, s := range scanners {
			// Scan the target with each scanner
			s.Scan(target, config.Headers)
		}
	}

	// Retrieve and process collected vulnerabilities
	vulnerabilities := scanner.GetVulnerabilities()

	// Generate the report
	fmt.Println("Scan completed. Generating report in format:", config.ReportFormat)
	generateReport(vulnerabilities)
}

// Function to generate the report in txt format
func generateReport(vulnerabilities []scanner.VulnerabilityDetails) {
	file, err := os.Create("scan_report.txt")
	if err != nil {
		fmt.Println("Error creating report file:", err)
		return
	}
	defer file.Close()

	for _, vuln := range vulnerabilities {
		file.WriteString(fmt.Sprintf("Target: %s\n", vuln.Endpoint))
		file.WriteString(fmt.Sprintf("  Type: %s\n", vuln.Type))
		file.WriteString(fmt.Sprintf("  Detected at: %s\n", vuln.DetectedAt.Format(time.RFC3339)))
		file.WriteString(fmt.Sprintf("  Payload: %s\n", vuln.Payload))
		file.WriteString(fmt.Sprintf("  Suggestion: %s\n", vuln.Suggestion))
		file.WriteString("\n")
	}

	fmt.Println("Report generated: scan_report.txt")
}
